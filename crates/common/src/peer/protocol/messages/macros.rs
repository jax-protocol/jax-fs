/// Macro for declaratively registering bidirectional message handlers
///
/// This macro generates:
/// - The Message enum with all request variants
/// - The Reply enum with all response variants
/// - The dispatch implementation that routes to handlers
///
/// # Example
///
/// ```rust,ignore
/// register_handlers! {
///     Ping(Ping),
/// }
/// ```
///
/// This generates:
/// - `Message::Ping(Ping)` variants
/// - Automatic dispatch to `PingHandler::_handle_request()`
/// - All the routing boilerplate
macro_rules! register_handlers {
    (
        $(
            $variant:ident($handler:ty)
        ),* $(,)?
    ) => {
        use crate::peer::protocol::bidirectional::BidirectionalHandler as _;

        /// Top-level message enum for the protocol
        ///
        /// This enum is auto-generated by the register_handlers! macro.
        /// To add a new message type, add it to the macro invocation.
        #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
        pub enum Message {
            $(
                #[doc = concat!("Message variant for ", stringify!($variant))]
                $variant(<$handler as crate::peer::protocol::bidirectional::BidirectionalHandler>::Message),
            )*
        }

        impl Message {
            /// Dispatch this message to the appropriate handler
            ///
            /// This method is auto-generated by the register_handlers! macro.
            pub async fn dispatch<L>(
                self,
                peer: &crate::peer::Peer<L>,
                sender_node_id: &crate::crypto::PublicKey,
                send: iroh::endpoint::SendStream,
            ) -> Result<(), iroh::protocol::AcceptError>
            where
                L: crate::bucket_log::BucketLogProvider,
                L::Error: std::error::Error + Send + Sync + 'static,
            {
                match self {
                    $(
                        Message::$variant(message) => {
                            tracing::debug!(concat!("Dispatching ", stringify!($variant), " message"));
                            <$handler>::_handle_message(peer, sender_node_id, message, send).await
                        }
                    )*
                }
            }
        }

        /// Top-level reply enum for the protocol
        ///
        /// This enum is auto-generated by the register_handlers! macro.
        #[allow(dead_code)]
        #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
        pub enum Reply {
            $(
                #[doc = concat!("Reply variant for ", stringify!($variant))]
                $variant(<$handler as crate::peer::protocol::bidirectional::BidirectionalHandler>::Reply),
            )*
        }
    };
}
